2021年度 サブゼミ 第11回 データハンドリング2
================
Yoshinari Namba
2021/6/24

|                                   |
|-----------------------------------|
| データハンドリングの第2回目です． |

# 0. Setup & Agenda

## 準備1: Rプロジェクト

RStudioを開いて右上のタブの File -> New Project
から新規プロジェクトを作成してくおいてください．

## 準備2: データ

今日は以下のデータを使用します．Rプロジェクトが作成出来たら，コードをコピペして実行しておいてください．

``` r
# 今日使うデータの作成
df_score <- data.frame(name = c('生徒C', '生徒A', '生徒B', '生徒A'), # 生徒名
                 class_size = c('small', 'large', 'small', 'large'), # 学級規模
                 math_score = c(80, NA, 75, 70),                     # 数学の点数
                 eng_score = c(70, 75, 80, 75))                      # 英語の点数
# 確認
df_score
```

    ##    name class_size math_score eng_score
    ## 1 生徒C      small         80        70
    ## 2 生徒A      large         NA        75
    ## 3 生徒B      small         75        80
    ## 4 生徒A      large         70        75

## 準備3: パッケージ

今日も`tidyverse`を使用します．インストールが済んでいない人は先ず`install.packages('tidyverse')`を実行してくださいね．

``` r
# tidyverseの呼び出し
library(tidyverse)
```

    ## Warning: package 'tidyverse' was built under R version 4.0.3

    ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 --

    ## v ggplot2 3.3.1     v purrr   0.3.4
    ## v tibble  3.0.1     v dplyr   1.0.2
    ## v tidyr   1.1.0     v stringr 1.4.0
    ## v readr   1.3.1     v forcats 0.5.0

    ## Warning: package 'tidyr' was built under R version 4.0.2

    ## Warning: package 'dplyr' was built under R version 4.0.3

    ## -- Conflicts ------------------------------------------ tidyverse_conflicts() --
    ## x dplyr::filter() masks stats::filter()
    ## x dplyr::lag()    masks stats::lag()

## Agenda

今日のAgendaは次の通りです．  
1. データ整理(続き)  
2. 文字列の操作  
3. グループワーク

# 1. tidyverseでデータ整理

## 1-1 ふりかえり

前回は主に`dplyr`を使った行列の扱い方や集計方法を学びました．今回はその続きです．  
まずは復習がてら前回のグループワークの答えを確認したいと思います．

``` r
# データの取り込み
df_review <- read.csv('wage1_editted.csv')

# 確認
head(df_review) 
```

    ##    wage educ exper female married industry
    ## 1  3.24   12    22      1       1 services
    ## 2  3.00   11     2      0       0    trade
    ## 3  8.75   16     9      0       1 profserv
    ## 4 11.25   18    15      0       0    trade
    ## 5  3.60   12    26      1       0    trade
    ## 6  6.25   16     8      1       0    trade

``` r
# 教育過剰・教育過少を作成
df_review_ans <- df_review %>% 
  group_by(industry) %>%           # 職業区分industry でグループ化
  mutate(ad_educ = mean(educ)) %>% # 適正教育年数 ad_educを定義
  ungroup() %>%                    #グループ解除
  mutate(ov_educ = ifelse(educ - ad_educ > 0, educ - ad_educ, 0), # 教育過剰年数 ov_educを定義
         un_educ = ifelse(educ - ad_educ < 0, ad_educ - educ, 0)) # 教育過少年数 un_educを定義

# 確認
head(df_review_ans) 
```

    ## # A tibble: 6 x 9
    ##    wage  educ exper female married industry ad_educ ov_educ un_educ
    ##   <dbl> <int> <int>  <int>   <int> <chr>      <dbl>   <dbl>   <dbl>
    ## 1  3.24    12    22      1       1 services    12.0  0.0377   0    
    ## 2  3       11     2      0       0 trade       12.3  0        1.30 
    ## 3  8.75    16     9      0       1 profserv    13.6  2.43     0    
    ## 4 11.2     18    15      0       0 trade       12.3  5.70     0    
    ## 5  3.60    12    26      1       0 trade       12.3  0        0.305
    ## 6  6.25    16     8      1       0 trade       12.3  3.70     0

パイプ`%>%`の意味を思い出しておいてくださいね．上の例では`df_review`を次の行のコマンドの第1引数に渡しています．  
ちなみに去年の
[三田論教育班](https://43c49aa2-d9d5-427b-b96b-9dc3dd5a6113.filesusr.com/ugd/a2f719_ede0c36e7b5742dabc5e980cd0503287.pdf)
は次のような分析を行いました(実際はパネルデータを使ったり学歴ミスマッチの別の定義でも試していたりするのでもう少し複雑です)．

``` r
out_educ <- lm(data = df_review_ans, 
               log(wage) ~ ad_educ + un_educ + ov_educ + exper + I(exper^2) + female + married)
summary(out_educ)
```

    ## 
    ## Call:
    ## lm(formula = log(wage) ~ ad_educ + un_educ + ov_educ + exper + 
    ##     I(exper^2) + female + married, data = df_review_ans)
    ## 
    ## Residuals:
    ##      Min       1Q   Median       3Q      Max 
    ## -1.65277 -0.23585 -0.04511  0.24318  1.27909 
    ## 
    ## Coefficients:
    ##               Estimate Std. Error t value Pr(>|t|)    
    ## (Intercept) -0.9727850  0.3462130  -2.810 0.005179 ** 
    ## ad_educ      0.1846454  0.0274527   6.726 5.45e-11 ***
    ## un_educ     -0.0418229  0.0122949  -3.402 0.000731 ***
    ## ov_educ      0.1074883  0.0142189   7.560 2.38e-13 ***
    ## exper        0.0352695  0.0055578   6.346 5.51e-10 ***
    ## I(exper^2)  -0.0006590  0.0001207  -5.462 7.89e-08 ***
    ## female      -0.3220350  0.0399404  -8.063 7.15e-15 ***
    ## married      0.0522308  0.0448755   1.164 0.245094    
    ## ---
    ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
    ## 
    ## Residual standard error: 0.4021 on 439 degrees of freedom
    ## Multiple R-squared:  0.4183, Adjusted R-squared:  0.409 
    ## F-statistic:  45.1 on 7 and 439 DF,  p-value: < 2.2e-16

## 1-2 並び替え: arrange()

データの観測を並び替えたいときは`dplyr::arrange()`を使います．ちなみに`X::Y()`というのは「`X`パッケージに入っている`Y()`という関数」という意味です．今回は様々なパッケージを使用しますが，全部`tidyverse`の中に入っているのでそれほど気にしなくて良いです．  
さて，もう一度データ`df_score`を見てみましょう．生徒名の順番がごちゃごちゃで気持ち悪いですね…

``` r
# 確認
df_score
```

    ##    name class_size math_score eng_score
    ## 1 生徒C      small         80        70
    ## 2 生徒A      large         NA        75
    ## 3 生徒B      small         75        80
    ## 4 生徒A      large         70        75

`name`の順番を昇順にしたいとき，次のようなコードを書きます．

``` r
df_score %>% 
  arrange(name)
```

    ##    name class_size math_score eng_score
    ## 1 生徒A      large         NA        75
    ## 2 生徒A      large         70        75
    ## 3 生徒B      small         75        80
    ## 4 生徒C      small         80        70

降順にしたいときも`arrange()`を使いますが，`desc()`と組み合わせて使うことになります．

``` r
df_score %>% 
  arrange(desc(name))
```

    ##    name class_size math_score eng_score
    ## 1 生徒C      small         80        70
    ## 2 生徒B      small         75        80
    ## 3 生徒A      large         NA        75
    ## 4 生徒A      large         70        75

もちろん`name`以外の変数でも昇順・降順に並べ替えられます．値が数値の場合，`-`を付け加えることで降順を指定できます．また，複数の変数を指定した場合は最初に指定した変数が同じ値の観測(行)について2番目に指定した変数の昇降で並べます．

``` r
# 数値の降順は -を付けるだけで良い
df_score %>% 
  arrange(-eng_score)
```

    ##    name class_size math_score eng_score
    ## 1 生徒B      small         75        80
    ## 2 生徒A      large         NA        75
    ## 3 生徒A      large         70        75
    ## 4 生徒C      small         80        70

``` r
# 複数の変数を指定
df_score %>% 
  arrange(eng_score, math_score)
```

    ##    name class_size math_score eng_score
    ## 1 生徒C      small         80        70
    ## 2 生徒A      large         70        75
    ## 3 生徒A      large         NA        75
    ## 4 生徒B      small         75        80

## 重複行の処理: distinct()

取得したデータには何らかの理由で「1つの観測主体に対して2つ以上の観測が含まれている」ときがあります．そのような状況でよく使うのが`distinct()`です．もう一度`df_score`を見てみましょう．

``` r
df_score
```

    ##    name class_size math_score eng_score
    ## 1 生徒C      small         80        70
    ## 2 生徒A      large         NA        75
    ## 3 生徒B      small         75        80
    ## 4 生徒A      large         70        75

生徒Aが2回含まれているのが確認できます．複数回登場する観測のうちどれか1つを抽出したい場合に`distinct()`を使います．引数は変数です．今回は観測主体は生徒であると考えて`name`を入れます．ただし，そのままだと`name`列だけが出力されてしまうので，`.keep_all`を`TRUE`にすることで，`name`以外の引数も残します．

``` r
df_score %>% 
  distinct(name, .keep_all = TRUE) # .keep_all = TRUE でname以外の列も残す
```

    ##    name class_size math_score eng_score
    ## 1 生徒C      small         80        70
    ## 2 生徒A      large         NA        75
    ## 3 生徒B      small         75        80

生徒Aの重複を解消することに成功しましたね．でも残った観測には`NA`が含まれてしまってる…  
実は`distinct()`は重複行の最初の行を残して2番目以降を削除するので，重複行の2番目以降のどれかを残したいときにはそのまま使うべきではありません．この場合に便利なのが先ほど学んだ`arrange()`です．なぜなら，昇順で`NA`は必ず最後に来るからです．

``` r
df_score %>% 
  arrange(name, class_size, math_score, eng_score) %>% 
  distinct(name, .keep_all = TRUE)
```

    ##    name class_size math_score eng_score
    ## 1 生徒A      large         70        75
    ## 2 生徒B      small         75        80
    ## 3 生徒C      small         80        70

## wide型->long型変換: pivot_longer()

実は`df_score`は前回に説明した「整ったデータ(tidy
data)」とは言えません．なぜでしょうか？
